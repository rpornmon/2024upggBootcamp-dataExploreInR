---
title: "2024 UPGG Bootcamp - Data Exploration"
author: "RP Pornmongkolsuk & Natalie Dzikowski"
date: "`r Sys.Date()`"
output: html_document
---

Learning objectives:
* Download and inspect data using R
* Explore data in a scientically motivated way
* Organize and manipulate data in preparation for summary and visualization


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Exploration and Clean-Up

## Blank et al., 2017 Transcriptomics Dataset
As a UPGG student, you might end up dealing with some type of "-omics" dataset (epigenomics, transcriptomics, proteomics, maybe multiomics!). Today, we'll be exploring and cleaning up a transcriptomics dataset from the following paper: 

*[Translational control of lipogenic enzymes in the cell cycle of synchronous, growing yeast cells](https://www.embopress.org/doi/full/10.15252/embj.201695050)* 

### What was the goal of the study?

The authors were searching for proteins that are under periodic translational control over the course of the cell cycle in yeast, using the size of the cell as a marker for cell cycle stage.

- Are there any proteins whose levels change depending on the stage of the cell cycle (a.k.a. the size of the cell)?
- Is the change in protein level due to transcriptional control (at the mRNA level), or translational control (at the protein level)?

### Which datasets will we be looking at?

Dataset 1: **A dataframe** of mRNA levels of over 6000 transcripts analyzed in THIS study. Specifically, the authors took the normalized read counts of each mRNA transcript, at each different cell size, found the mean read count for each gene across all of the cell sizes, and expressed the mRNA levels of each gene as a ratio of the level at each cell size over the mean. These ratios were then log2-transformed.

Dataset 2: **A vector** of 144 transcripts whose levels were found to fluctuate over the course of the cell cycle, both in this study, and in *Spellman et. al, 1998*. These are the genes under "periodic transcriptional control".

In addition to these, we will need help from some gene annotation files to understand the data. 

### Who cares?

mRNA sequncing has been fundamental to genomics research. It's very possible you might generate data like this in your own research. You may be analying changing mRNA levels in the cell due to a normal cellular process, or due to some genetic, epigenetic, or chemical perturbation you did in an experiment. 

What if you never do mRNA sequencing? Still, at some point, you may have to deal with data formatted in a really similar way (protein levels, fluorescence on DNA microarrays, etc.).

## Refresher
Here's a refresher on how to download the dataset and load it into the "R environment".



## Download data
```{r download data}
library(tidyverse)
mRNA_file <- "ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE81nnn/GSE81932/suppl/GSE81932_Dataset01.txt.gz"
mRNA_data <- read_lines(mRNA_file)
periodically_expressed_genes_file <- "ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE81nnn/GSE81932/suppl/GSE81932_Dataset02.txt.gz"
periodically_expressed_genes <- read_lines(periodically_expressed_genes_file)
```

## Explore data
Try "printing" the values contained in the variable `periodically_expressed_genes`.
```{r}
periodically_expressed_genes
print(periodically_expressed_genes)
```

`periodically_expressed_genes` is a "vector" data type. It is similar to an "array" or a "list" in some other programming languages, BUT R has its own version of "list." Essentially, R has both "vector" and "list" data types, and they function differently. "Vectors" are what you would think of when you think of Python's "array" or "list"


### Vector
A "vector" is a list of values that, importantly, are of the same type. This is the most common data type in R. 

```{r}
v1 <- c() # Empty vector
v2 <- c(1) # Vector of length 1 and of type numeric
v3 <- c("Hello", "World") # Vector of length 2 and of type character
v4 <- c(1, "hi", TRUE, 1+2) # R is smart enough to coerce the type of all element into one that can be applied to all of them -- in this case, character, designated by " marks.
print(v4)
```


## Download annotation
```{r}
ribi_annotation_file <- "ribosome_biogenesis_annotations.txt"

read_lines(ribi_annotation_file, n_max = 10)
```

```{r}
ribi_annotation <- read_tsv(ribi_annotation_file, comment = "!")
```

```{r}
str(periodically_expressed_genes)
```


```{r}
names(ribi_annotation)
ribi_annotation
```


### List
List is a more flexible data type - it can contain a mixture elements of various data types.



### Data Frame 
This is arguably the most useful feature of R. There's a reason we use spreadsheets. 
And it is particularly efficient too. 

```{r}
ribi_annotation
```


```{r}
my_tib <- tibble(mtcars)
```

```{r}
names(my_tib)
```

## Tidyverse 
1. What is Tidyverse?
Tidyverse is a collection of R packages that had been designed and developed for data science. R is not a new language, and Tidyverse's philosophy is about reducing the things in R that didn't stand the test of time and introducing cleaner, more understandable grammar into the coding style. 

Tibble 
A table is one of the most common way to store and understand data. Think about a spreadsheet like Excel or Google Sheets. It portrays multi-dimentional data and its relational information between data points across columns. So the basis of data exploration and cleanup begins with a table. R has a built-in data structure that looks like a table called `data frame`. Tidyverse attempts to improve on `data frame` and came up with `tibble`. In general, they are about equivalent in terms of function. For the sake of this lesson, we'll use `tibble` as any Tidyverse read function would output a `tibble` by default. This is one way to instantiate a tibble. Key components are column names and values. Each column can only contain one data type.
```{r}
df1 <- data.frame(x = c(1,2), y = c(3,4))
df2 <- tibble(x = c(1,2), y = c(3,4))
df1
df2
```
You can convert any existing data frame into a tibble.
```{r}
as_tibble(iris)
```

Subsetting
```{r}
df <- tibble(
  x = runif(5),
  y = rnorm(5)
)
# Extract by name 1
df$x
# Extract by name 2
df[["x"]]
# Extract by column index 1
df[[1]]
# Extract by column index 2
df[,1]
```


```{r}
str(parse_logical(c("TRUE", "FALSE", "NA")))

```

Tidydata
1. Each variable must have its own column
2. Each observation must have its own row
3. Each value must have its own cell

```{r}
table1 %>%
    count(year, wt = cases)
```

Pivoting data

## Let's look the data from the paper


Often times, a dataframe will have a few lines of information that explain its contents to the reader, as we saw in our ribi annotation file. There may also be a header that labels each column. Let's check if our mRNA dataframe has any of those:

```{r}
head(mRNA_data)
```

It looks like there is one header line at the very beginning. Let's keep this in mind. 

Let's also double check there aren't any extra lines at the end of the file, just in case:

```{r}
tail(mRNA_data)
```
Looks good! Let's make this into a tibble, so that the header is recognized.

```{r}
mRNA <- read_tsv(mRNA_file)
```
### Exercise 1: How many transcripts were analyzed in total?

```{r}
length(mRNA_data)
```

There are 6714 lines, so without the header, there are 6713 entries.

Or, just check out the tibble:

```{r}
mRNA
```

### Exercise 2: How many periodically expressed genes did Blank et. al and Spellman et. al find in common?

```{r}
length(periodically_expressed_genes)
```

Only 144 genes were identified as "periodically expressed" during the cell cycle, when data from both papers was intersected.

`length()` is a good way to get an overview of a dataset, but can we always be sure that each line corresponds to a unique gene? What if there are duplicates?

```{r}
mRNA
```
```{r}
n_distinct(mRNA$ORF)

n_distinct(periodically_expressed_genes)
```

Looks like every entry is unique.
## Let's explore our ribi annotation file

Earlier, we cleaned up the annotation file for the ribosome biogenesis genes. 

Recap: How did we do this?
```{r}
ribi_annotation <- read_tsv(ribi_annotation_file, comment = "!")
```

This created a dataframe object, while marking any line starting with "!" as a comment, and not part of the dataframe itself. The header will still be read into the dataframe, since it was not marked with a "!".


Now we can view the contents and structure:

```{r}
ribi_annotation
```

```{r}
str(ribi_annotation)
```

### Which parts of the dataframe are we interested in?

The datasets in this study named transcripts by their gene IDs, specific to *S. cerevisiae* - these can be found in the column 'Systematic Name/Complex Accession'. The 'Gene/Complex' column provides a more common name for that gene. 

Additionally, we have the column "Gene Ontology Term" for each gene, associating it with a biological process. The file we downloaded was called `ribosome_biogenesis_annotations.txt`, so we'd probably assume that these are only genes involved in ribosome biogenesis. 

Still, let's double check that to be sure!

```{r}
n_distinct(ribi_annotation$Qualifier)

distinct(ribi_annotation, Qualifier)
```

```{r}
n_distinct(ribi_annotation$`Gene Ontology Term`)

distinct(ribi_annotation, `Gene Ontology Term`)
```

So, clearly, we only have genes involved in ribosome biogenesis. 

The most useful part of this annotation file will be to convert the yeast gene IDs into more common names for downtstream analyses.

### Exercise 3 (Discussion): 

Why do you think we provided 1 argument for the `n_distinct()` function, but 2 arguments for `distinct()` ? 

## Cleaning up the annotation file

First, let's take only the columns we want from the dataframe:

```{r}
ribi_annotation_names <- select(ribi_annotation, Gene = "Gene/Complex", SystematicName = "Systematic Name/Complex Accession")

ribi_annotation_names
```

Next, we should check if there are any duplicate gene entries, or if each line is unique. 

### Exercise 4: Check the number of unique gene name/systematic name combinations. Are there duplicates?

*Hint: You only have to use functions we have already learned.*

```{r}
ribi_annotation_names

n_distinct(ribi_annotation_names)
```
Uh oh. Looks like there are duplicates we don't want.

### Exercise 5: First, create a new dataframe object with duplicates removed. Then, double-check that this was done correctly.

```{r}
ribi_genes <- distinct(ribi_annotation_names)

ribi_genes

n_distinct(ribi_genes)
```

Looks like our whole dataframe is made up of distinct entries now!

## Which ribosome biogenesis genes are periodically expressed during the cell cycle?

```{r}
ribi_genes_periodic <- filter(ribi_genes, SystematicName %in% periodically_expressed_genes)

ribi_genes_periodic
```

By doing this, we are just searching for the Systematic Names of the genes in the ribi annotation file that pop up in the list of 144 periodically expressed genes.

We can now see that 34/144 periodically expressed genes are involved in ribosome biogenesis (or that 34/187 ribosome biogenesis genes are periodically expressed during the cell cycle). 

We can also check if our favorite gene is on this list! It would be easy enough to do manually, but let's pretend our dataframe is still really long...

```{r}
"NUG1" %in% ribi_genes_periodic$Gene
```

It's there! Let's print the line to see what its Systematic Name is.

```{r}
filter(ribi_genes_periodic, Gene == "NUG1")
```

### Exercise 6: Check whether the gene "RPS6B" is a periodically expressed gene, and try printing its line to see its systematic name.

Solution:
```{r}
"RPS6B" %in% ribi_genes_periodic$Gene
```

```{r}
filter(ribi_genes_periodic, Gene == "RPS6B")
```

Oops! That one's not there.

## What about genes with other functions?

Up until now, we were looking only at ribosome biogenesis genes, since that was a major GO term that came up in the data. What about the genes involved in other biological processes?

### Download annotations from Dryad

You should have been able to download the Data Folder from [Dryad](https://datadryad.org/stash/dataset/doi:10.5061/dryad.d644f) yesterday.

### Exercise 7: Practice unzipping the folder and moving the file `scer-mrna-protein-absolute-estimate.txt` into your ./data directory, using only the command line.

```{bash}
gunzip -dk ../Downloads/doi_10_5061_dryad_d644f__v20160422.zip

mv ../Downloads/doi_10_5061_dryad_d644f__v20160422/scer-mrna-protein-absolute-estimate.txt ./data
```

Let's read the file

```{r}
scer_names_estimates_file <- "../data/scer-mrna-protein-absolute-estimate.txt"

read_lines(scer_names_estimates_file, n_max = 10)
```
How would you turn this into a tibble, ignoring the comments starting with a "#" ?
```{r}
scer_names_estimates <- read_tsv(scer_names_estimates_file, comment = "#")

str(scer_names_estimates)
```

The columns `"orf"` and `"gene"` will be useful to us for now. 

### Exercise #8: Create a new dataframe with only the columns `"orf"` and `"gene"`.
```{r}
scer_gene_names <- select(scer_names_estimates, Gene = gene, SystematicName = orf)
```

### Challenge: 
1. Get the names of genes from the Dryad annotations that are periodically expressed.
2. Extract only the common gene names from the output of 1.
3. Is the gene NOP56 on this list?

```{r}
filter(scer_gene_names, SystematicName %in% periodically_expressed_genes)

filter(scer_gene_names, SystematicName %in% periodically_expressed_genes) %>% select(Gene)

filter(scer_gene_names, SystematicName %in% periodically_expressed_genes, Gene == "NOP56")

filter(scer_gene_names, Gene == "NOP56")

YLR197W" %in% periodically_expressed_genes
```

Looks like NOP56 is not periodically expressed (but it definitely is in the gene annotation file). To double-check, its systematic name is indeed not in the list of periodically expressed genes.

### Exploring more of the Dryad data

This dataset actually has a lot more interesting information, like mRNA and protein levels for each gene. To explore these columns, we can use the `arrange()` function. This will allow us to sort the dataframe according to a variable we're interested in.

```{r}
arrange(scer_names_estimates, gene)
```

The default is ascending order. 

```{r}
arrange(scer_names_estimates, gene) %>% tail()
```

What would this do?

```{r}
arrange(scer_names_estimates, desc(gene))
```

What about this?

```{r}
arrange(scer_names_estimates, desc(gene), mrna)
```

Wait, can't we just use `sort()` instead or `arrange()`?

```{r}
arrange(scer_names_estimates, desc(gene), mrna) %>% tail()
```

With `arrange()`, NA values automatically get put the end, regardless of whether you're arranging in ascending or descending order. This makes removal or data exploration more convenient.


## Let's put the two biggest datasets together

What if our favorite gene is periodically expressed, but it was only identified in the 2017 study, but not the 1998 study? (This would mean it was never included in `periodically_expressed_genes`).

Well, we have access to all of the mRNA data (>6000 transcripts), and a comprehensive annotation set from Dryad. Let's put these two together to see what's happening to ALL of the genes, so then we can check what's happening to our favorite genes.

There are a bunch of ways to join datasets together on common keys. We can try out a bunch of these `join` methods and see what we get.

A "key" that both datasets have in common is the "systematic name". However, this list of gene IDs is labeled "SystematicName" in the Dryad annotations, but labeled "ORF" in Dataset01 (mRNA). Let's change the name of one of the columns to match:

```{r}
names(mRNA)[1] <- "SystematicName"

mRNA
```

Let's perform a `left_join()` on the two datasets, following this format:

`joined_df <- left_join(x, y, by = "key")`

This will take all rows of dataframe 'x', & keep all of the columns in 'x', while merging dataframe 'y' on the desired key and appending columns from 'y', with values that correctly correspond to each key.

That might sound confusing at first, so let's just see what happens:

```{r}
mRNA_named <- left_join(mRNA, scer_gene_names, by = "SystematicName")

mRNA_named
```

This will let us search (via their common names) whether our favorite genes are indeed periodically expressed. For example:

```{r}
filter(mRNA_named, Gene %in% c("ACT1", "NOP16", "NOP56"))
```

There are definitely some fluctuations in mRNA. Interesting! Maybe they just didn't make the cut according to the parameters/thresholds used by the authors; or, maybe they just weren't identified in both the 2017 and 1998 papers. Following the authors' methodology, your data is now set up for you to find the culprit (on your own time, if you're interested). 

## Saving your work

You've done all this work - be sure to save it now!

```{r}
write_csv(mRNA_named, "../data/mRNA_data_with_gene_names.csv")
```

## Reshaping tibbles

Sometimes, we might want to reshape a tibble to make it better formatted for plotting/visualization later on. For example, let's go back to Dataset01:

```{r}
mRNA

gather(mRNA_named,key=Vol,value="log2_ratio",-SystematicName,-Gene)
```

What do you notice changed about Dataset01?

This is easier to deal with now, if we want to visualize the data. But let's make our lives even easier with the help of a few additional functions:

```{r}
gather(mRNA_named,key=Vol,value="log2_ratio",-SystematicName,-Gene) %>%
    separate(Vol,into="Vol_fL")
```

```{r}
gather(mRNA_named,key=Vol,value="log2_ratio",-SystematicName,-Gene) %>%
    separate(Vol,into="Vol_fL")  %>%
    mutate(Vol_fL = as.numeric(Vol_fL))
```

Wait, doesn't that look exactly the same? What was the purpose of `mutate()`?

```{r}
mRNA_data_gathered <- 
gather(mRNA_data,key=Vol,value="log2_ratio",-Name,-Gene) %>%
    separate(Vol,into="Vol_fL") %>%
    mutate(Vol_fL = as.numeric(Vol_fL))
```

Now, we can easily pick 3 genes we're most interested in, and plot their fluctuating mRNA levels over the course of the cell cycle!

Let's save that information into a small dataframe, and then Kayla and Gabe will guide you through plotting.

```{r}
mRNA_data_3genes <- filter(mRNA_data_gathered, Gene %in% c("ACT1","NOP16","NOP56"))
```

(If you'd like, you can save this as a .csv as well).

## Questions?
