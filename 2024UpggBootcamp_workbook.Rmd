---
title: "2024 UPGG Bootcamp - Data Exploration"
author: "RP Pornmongkolsuk & Natalie Dzikowski"
date: "`r Sys.Date()`"
output: html_document
---

Learning objectives:
* Download and inspect data using R
* Explore data in a scientically motivated way
* Organize and manipulate data in preparation for summary and visualization


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Exploration and Clean-Up

## Blank et al., 2017 Transcriptomics Dataset
As a UPGG student, you might end up dealing with some type of "-omics" dataset (epigenomics, transcriptomics, proteomics, maybe multiomics!). Today, we'll be exploring and cleaning up a transcriptomics dataset from the following paper: 

*[Translational control of lipogenic enzymes in the cell cycle of synchronous, growing yeast cells](https://www.embopress.org/doi/full/10.15252/embj.201695050)* 

### What was the goal of the study?

The authors were searching for proteins that are under periodic translational control over the course of the cell cycle in yeast, using the size of the cell as a marker for cell cycle stage.

- Are there any proteins whose levels change depending on the stage of the cell cycle (a.k.a. the size of the cell)?
- Is the change in protein level due to transcriptional control (at the mRNA level), or translational control (at the protein level)?

### Which datasets will we be looking at?

Dataset 1: **A dataframe** of mRNA levels of over 6000 transcripts analyzed in THIS study. Specifically, the authors took the normalized read counts of each mRNA transcript, at each different cell size, found the mean read count for each gene across all of the cell sizes, and expressed the mRNA levels of each gene as a ratio of the level at each cell size over the mean. These ratios were then log2-transformed.

Dataset 2: **A vector** of 144 transcripts whose levels were found to fluctuate over the course of the cell cycle, both in this study, and in *Spellman et. al, 1998*. These are the genes under "periodic transcriptional control".

In addition to these, we will need help from some gene annotation files to understand the data. 

### Who cares?

mRNA sequncing has been fundamental to genomics research. It's very possible you might generate data like this in your own research. You may be analying changing mRNA levels in the cell due to a normal cellular process, or due to some genetic, epigenetic, or chemical perturbation you did in an experiment. 

What if you never do mRNA sequencing? Still, at some point, you may have to deal with data formatted in a really similar way (protein levels, fluorescence on DNA microarrays, etc.).

## Refresher
Here's a refresher on how to download the dataset and load it into the "R environment".



## Download data
```{r download data}
library(tidyverse)
mRNA_file <- "ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE81nnn/GSE81932/suppl/GSE81932_Dataset01.txt.gz"
mRNA_data <- read_lines(mRNA_file)
periodically_expressed_genes_file <- "ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE81nnn/GSE81932/suppl/GSE81932_Dataset02.txt.gz"
periodically_expressed_genes <- read_lines(periodically_expressed_genes_file)
```

## Explore data
Try "printing" the values contained in the variable `periodically_expressed_genes`.
```{r}
periodically_expressed_genes
print(periodically_expressed_genes)
```

`periodically_expressed_genes` is a "vector" data type. It is similar to an "array" or a "list" in some other programming languages, BUT R has its own version of "list." Essentially, R has both "vector" and "list" data types, and they function differently. "Vectors" are what you would think of when you think of Python's "array" or "list"


### Vector
A "vector" is a list of values that, importantly, are of the same type. This is the most common data type in R. 

```{r}
v1 <- c() # Empty vector
v2 <- c(1) # Vector of length 1 and of type numeric
v3 <- c("Hello", "World") # Vector of length 2 and of type character
v4 <- c(1, "hi", TRUE, 1+2) # R is smart enough to coerce the type of all element into one that can be applied to all of them -- in this case, character, designated by " marks.
print(v4)
```


## Download ribosome biogenesis annotations
```{r}
ribi_annotation_file <- "ribosome_biogenesis_annotations.txt"

read_lines(ribi_annotation_file, n_max = 10)
```

```{r}
ribi_annotation <- read_tsv(ribi_annotation_file, comment = "!")
```

```{r}
str(periodically_expressed_genes)
```


```{r}
names(ribi_annotation)
ribi_annotation
```

### Vectors

Vectors have some specific properties that you can call pretty handily with built-in functions. 
```{r}
# prints the type of elements contained within vector
typeof(v4)
# Prints the length of the vector
length(v4)
```

Concatenate vectors
```{r}
v5 <- c(v3, v4)
print(v5)
```

Vector arithmatic 
```{r}
x <- c(1, 2, 3, 4)
x * 2
```

Vector recycling
```{r}
y <- c(5, 6, 7)
x + y
```

Common statistical functions
```{r}
sum(x)
min(x)
max(x)
mean(x)
median(x)
sd(x)
```

```{r}
summary(x)
```

Indexing vectors 
R uses the 1-based indexing system, meaning the first element begins at 1. (Python, for example, is a zero-based indexing system.)
```{r}
x
x[1]
x[-1]
x[3:4]
x[4:1]
x[1:length(x)-1]
```

### List
List is a more flexible data type - it can contain a mixture elements of various data types. We'll go through this really quickly.

Creating a list
```{r}
my_list <- list("Hello", 1, TRUE) # Mixed types of element
print(my_list)
```

```{r}
length(my_list)
```


Indexing a list
```{r}
my_list[[1]]
```

Appending a list, list can contain vector
```{r}
my_list[[5]] <- 1:10
my_list
```

Indexing
```{r}
my_list[[5]][7]
```


A list within a list
```{r}
my_list[[4]] <- list("World")
my_list
```

```{r}
my_list[[4]][[1]]
```



### Data Frame 
This is arguably the most useful feature of R. There's a reason we use spreadsheets, they show data in inter-relational fashion. 
And it is particularly efficient too. 

Creating a data frame
```{r}
df <- data.frame(1:5,
                 6:10)
df
```

Think of data frame as like a stack of vectors (each column). To be able to make sense of the data, we want to add column names to designate what the values mean.
```{r}
names(df)
names(df) <- c("first.column", "second.column")
names(df) # Note how codes are evaluated line-by-line sequentially?
```

You can think of a data frame as a specialized type of `list` (with constraints), where each vector is an element of the list. BUT the number of rows must be of the same lengths. 
```{r}
typeof(df)
```

```{r}
length(df)
df[[2]]
```

Properties of data frame
```{r}
dim(df)
ncol(df)
nrow(df)
```

Indexing, extracting information from data frame
```{r}
df[[1]] # Same as list
```

```{r}
df$first.column # Most common way to do it
```

R is a row-based, meaning first index refers to the row number, then column number
```{r}
df[1,2] # row 1, column 2
```

Or, you can call by column name, and index like a normal vector.
```{r}
df$second.column[1]
```

R has some built-in data frames that you can play with. 
```{r}
mtcars
```

```{r}
iris
```

## Tidyverse 
1. What is Tidyverse?
Tidyverse is a collection of R packages that had been designed and developed for data science. R is not a new language, and Tidyverse's philosophy is about reducing the things in R that didn't stand the test of time and introducing cleaner, more understandable grammar into the coding style. 

Tibble 
A table is one of the most common way to store and understand data. Think about a spreadsheet like Excel or Google Sheets. It portrays multi-dimentional data and its relational information between data points across columns. So the basis of data exploration and cleanup begins with a table. R has a built-in data structure that looks like a table called `data frame`. Tidyverse attempts to improve on `data frame` and came up with `tibble`. In general, they are about equivalent in terms of function. For the sake of this lesson, we'll use `tibble` as any Tidyverse read function would output a `tibble` by default. This is one way to instantiate a tibble. Key components are column names and values. Each column can only contain one data type.
```{r}
my_tib <- tibble(mtcars)
```

```{r}
names(my_tib)
```

Conventionally, each row contains observations, each column contains variables, and each cell contains values. 
```{r}
mtcars
```



```{r}
df1 <- data.frame(x = c(1,2), y = c(3,4))
df2 <- tibble(x = c(1,2), y = c(3,4))
df1
df2
```
You can convert any existing data frame into a tibble.
```{r}
as_tibble(iris)
```

Subsetting
```{r}
tb <- tibble(
  x = runif(5),
  y = rnorm(5)
)
# Extract by name 1
tb$x
# Extract by name 2
tb[["x"]]
# Extract by column index 1
tb[[1]]
# Extract by column index 2
tb[,1]
```

## Dplyr
Tidyverse is a meta-package, meaning it includes multiple packages within it. One of them is `dplyr` which contains functions involving common data manipulation task.

```{r}
table1
```

### Select()
```{r}
select(table1, year)
```

### Filter()
Compare to base R, tidyverse is trying to reduce redundancy of repeating the name of the variable. 
```{r}
table1[table1$year == 2000,]
```

```{r}
filter(table1, year == 2000) # Much cleaner
```

Chaining different functions become wordy and unintuitive to read. Tidyverse tries to mitigate this problem by introducing its own grammar structure that helps aligning code with how your brain would normally work. Sequentiality is important.
```{r}
select(filter(table1, year == 2000), country)
```
Instead, you can use `pipe`, this is now even cleaner than before, you only have to type the name `table1` once. 
```{r}
table1 %>%
    filter(year == 2000) %>%
    select(country)
table1 %>%
    filter(country == "Afghanistan") %>%
    select(-country)
```

### Mutate()
Mutate is a very powerful function. It adds another column, and you can pull information from different
```{r}
table1 %>%
    mutate(rate = cases / population * 10000) # This doesn't happen in-place. Don't forget to assign it to the same variable or new variable. 
```

Note on naming, you don't want to include spaces
```{r}
my_tib$'miles per gallon' <- 1:32 
my_tib$'miles per gallon'

my_tib %>% 
    filter(miles per gallon > 10)
# space has meaning in programming!!! 

my_tib %>%
    filter(`miles per gallon` > 10) # DON"T DO THIS

my_tib$miles_per_gallon <- 1:32

```

### Arrange()
```{r}
table1 %>%
    mutate(rate = cases / population * 10000) %>%
    arrange(desc(rate))
```

### Pivoting data
The principles of tidy data seem so obvious that you might wonder if you’ll ever encounter a dataset that isn’t tidy. Unfortunately, however, most data that you will encounter will be untidy. There are two main reasons:

Most people aren’t familiar with the principles of tidy data, and it’s hard to derive them yourself unless you spend a lot of time working with data.

Data is often organised to facilitate some use other than analysis. For example, data is often organised to make entry as easy as possible.

This means for most real analyses, you’ll need to do some tidying. The first step is always to figure out what the variables and observations are. Sometimes this is easy; other times you’ll need to consult with the people who originally generated the data. The second step is to resolve one of two common problems:

One variable might be spread across multiple columns.

One observation might be scattered across multiple rows.

Typically a dataset will only suffer from one of these problems; it’ll only suffer from both if you’re really unlucky! To fix these problems, you’ll need the two most important functions in tidyr: pivot_longer() and pivot_wider().


```{r}
table4a
```

1999 and 2000 are recording of the same variable (cases) but from different years. It is intuitive to place them in different columns next to each other if we want to compare by eyes. But in plotting, you might want to merge them into one column called "cases". Kayla and Gabriel will talk more about this in the afternoon. 
```{r}
table4a %>%
    pivot_longer(c('1999', '2000'), 
                 names_to = "year", # What should we call the new column that will contain the original names?
                 values_to = "cases") # What should we call the new column that will contain the original values?
```
Note that year is of type `chr`
```{r}
table4a %>%
    pivot_longer(c('1999', '2000'), 
                 names_to = "year", # What should we call the new column that will contain the original names?
                 values_to = "cases") %>% # What should we call the new column that will contain the original values? 
    mutate(year = parse_double(year))
```

### Pivot Wider
```{r}
table2
```

```{r}
table2 %>%
    pivot_wider(names_from = type, # what should the new column names be
                values_from = count) # where should the values in new column come from
```



### Summarize()
```{r}
table1 %>%
    summarize(max = max(cases), mean = mean(cases))
```

### Group_by()
```{r}
table1 %>%
    group_by(year) %>%
    count
```


Summarize within group
```{r}
table1 %>%
    group_by(year) %>%
    summarize(max(cases), mean(cases))
```

### Exercise
I'll make some dirty, dummy data and let them
1. Load data
2. Rename columns
3. Mutate a new column
4. Sort the column
5. Remove NAs
6. Remove unused columns
7. Pivot longer/wider


<<<<<<< Updated upstream

## Let's look the data from the paper


Often times, a dataframe will have a few lines of information that explain its contents to the reader, as we saw in our ribi annotation file. There may also be a header that labels each column. Let's check if our mRNA dataframe has any of those:

```{r}
head(mRNA_data)
```

It looks like there is one header line at the very beginning. Let's keep this in mind. 

Let's also double check there aren't any extra lines at the end of the file, just in case:

```{r}
tail(mRNA_data)
```
Looks good! Let's make this into a tibble, so that the header is recognized.

```{r}
mRNA <- read_tsv(mRNA_file)
```
### Exercise 1: How many transcripts were analyzed in total?

```{r}
length(mRNA_data)
```

There are 6714 lines, so without the header, there are 6713 entries.

Or, just check out the tibble:

```{r}
mRNA
```

### Exercise 2: How many periodically expressed genes did Blank et. al and Spellman et. al find in common?

```{r}
length(periodically_expressed_genes)
```

Only 144 genes were identified as "periodically expressed" during the cell cycle, when data from both papers was intersected.

`length()` is a good way to get an overview of a dataset, but can we always be sure that each line corresponds to a unique gene? What if there are duplicates?

```{r}
mRNA
```
```{r}
n_distinct(mRNA$ORF)

n_distinct(periodically_expressed_genes)
```

Looks like every entry is unique.
## Let's explore our ribi annotation file

Earlier, we cleaned up the annotation file for the ribosome biogenesis genes. 

Recap: How did we do this?
```{r}
ribi_annotation <- read_tsv(ribi_annotation_file, comment = "!")
```

This created a dataframe object, while marking any line starting with "!" as a comment, and not part of the dataframe itself. The header will still be read into the dataframe, since it was not marked with a "!".


Now we can view the contents and structure:

```{r}
ribi_annotation
```

```{r}
str(ribi_annotation)
```

### Which parts of the dataframe are we interested in?

The datasets in this study named transcripts by their gene IDs, specific to *S. cerevisiae* - these can be found in the column 'Systematic Name/Complex Accession'. The 'Gene/Complex' column provides a more common name for that gene. 

Additionally, we have the column "Gene Ontology Term" for each gene, associating it with a biological process. The file we downloaded was called `ribosome_biogenesis_annotations.txt`, so we'd probably assume that these are only genes involved in ribosome biogenesis. 

Still, let's double check that to be sure!

```{r}
n_distinct(ribi_annotation$Qualifier)

distinct(ribi_annotation, Qualifier)
```

```{r}
n_distinct(ribi_annotation$`Gene Ontology Term`)

distinct(ribi_annotation, `Gene Ontology Term`)
```

So, clearly, we only have genes involved in ribosome biogenesis. 

The most useful part of this annotation file will be to convert the yeast gene IDs into more common names for downtstream analyses.

### Exercise 3 (Discussion): 

Why do you think we provided 1 argument for the `n_distinct()` function, but 2 arguments for `distinct()` ? 

## Cleaning up the annotation file

First, let's take only the columns we want from the dataframe:

```{r}
ribi_annotation_names <- select(ribi_annotation, Gene = "Gene/Complex", SystematicName = "Systematic Name/Complex Accession")

ribi_annotation_names
```

Next, we should check if there are any duplicate gene entries, or if each line is unique. 

### Exercise 4: Check the number of unique gene name/systematic name combinations. Are there duplicates?

*Hint: You only have to use functions we have already learned.*

```{r}
ribi_annotation_names

n_distinct(ribi_annotation_names)
```
Uh oh. Looks like there are duplicates we don't want.

### Exercise 5: First, create a new dataframe object with duplicates removed. Then, double-check that this was done correctly.

```{r}
ribi_genes <- distinct(ribi_annotation_names)

ribi_genes

n_distinct(ribi_genes)
```

Looks like our whole dataframe is made up of distinct entries now!

## Which ribosome biogenesis genes are periodically expressed during the cell cycle?

```{r}
ribi_genes_periodic <- filter(ribi_genes, SystematicName %in% periodically_expressed_genes)

ribi_genes_periodic
```

By doing this, we are just searching for the Systematic Names of the genes in the ribi annotation file that pop up in the list of 144 periodically expressed genes.

We can now see that 34/144 periodically expressed genes are involved in ribosome biogenesis (or that 34/187 ribosome biogenesis genes are periodically expressed during the cell cycle). 

We can also check if our favorite gene is on this list! It would be easy enough to do manually, but let's pretend our dataframe is still really long...

```{r}
"NUG1" %in% ribi_genes_periodic$Gene
```

It's there! Let's print the line to see what its Systematic Name is.

```{r}
filter(ribi_genes_periodic, Gene == "NUG1")
```

### Exercise 6: Check whether the gene "RPS6B" is a periodically expressed gene, and try printing its line to see its systematic name.

Solution:
```{r}
"RPS6B" %in% ribi_genes_periodic$Gene
```

```{r}
filter(ribi_genes_periodic, Gene == "RPS6B")
```

Oops! That one's not there.

## What about genes with other functions?

Up until now, we were looking only at ribosome biogenesis genes, since that was a major GO term that came up in the data. What about the genes involved in other biological processes?

### Download full gene annotations from Dryad

You should have been able to download the Data Folder from [Dryad](https://datadryad.org/stash/dataset/doi:10.5061/dryad.d644f) yesterday.

### Exercise 7: Practice unzipping the folder and moving the file `scer-mrna-protein-absolute-estimate.txt` into your ./data directory, using only the command line.

```{bash}
gunzip -dk ../Downloads/doi_10_5061_dryad_d644f__v20160422.zip

mv ../Downloads/doi_10_5061_dryad_d644f__v20160422/scer-mrna-protein-absolute-estimate.txt ./data
```

Let's read the file

```{r}
scer_names_estimates_file <- "../data/scer-mrna-protein-absolute-estimate.txt"

read_lines(scer_names_estimates_file, n_max = 10)
```
How would you turn this into a tibble, ignoring the comments starting with a "#" ?
```{r}
scer_names_estimates <- read_tsv(scer_names_estimates_file, comment = "#")

str(scer_names_estimates)
```

The columns `"orf"` and `"gene"` will be useful to us for now. 

### Exercise #8: Create a new dataframe with only the columns `"orf"` and `"gene"`.
```{r}
scer_gene_names <- select(scer_names_estimates, Gene = gene, SystematicName = orf)
```

### Challenge: 
1. Get the names of genes from the Dryad annotations that are periodically expressed.
2. Extract only the common gene names from the output of 1.
3. Is the gene NOP56 on this list?

```{r}
filter(scer_gene_names, SystematicName %in% periodically_expressed_genes)

filter(scer_gene_names, SystematicName %in% periodically_expressed_genes) %>% select(Gene)

filter(scer_gene_names, SystematicName %in% periodically_expressed_genes, Gene == "NOP56")

filter(scer_gene_names, Gene == "NOP56")

YLR197W" %in% periodically_expressed_genes
```

Looks like NOP56 is not periodically expressed (but it definitely is in the gene annotation file). To double-check, its systematic name is indeed not in the list of periodically expressed genes.

### Exploring more of the Dryad data

This dataset actually has a lot more interesting information, like mRNA and protein levels for each gene. To explore these columns, we can use the `arrange()` function. This will allow us to sort the dataframe according to a variable we're interested in.

```{r}
arrange(scer_names_estimates, gene)
```

The default is ascending order. 

```{r}
arrange(scer_names_estimates, gene) %>% tail()
```

What would this do?

```{r}
arrange(scer_names_estimates, desc(gene))
```

What about this?

```{r}
arrange(scer_names_estimates, desc(gene), mrna)
```

Wait, can't we just use `sort()` instead or `arrange()`?

```{r}
arrange(scer_names_estimates, desc(gene), mrna) %>% tail()
```

With `arrange()`, NA values automatically get put the end, regardless of whether you're arranging in ascending or descending order. This makes removal or data exploration more convenient.


## Let's put the two biggest datasets together

What if our favorite gene is periodically expressed, but it was only identified in the 2017 study, but not the 1998 study? (This would mean it was never included in `periodically_expressed_genes`).

Well, we have access to all of the mRNA data (>6000 transcripts), and a comprehensive annotation set from Dryad. Let's put these two together to see what's happening to ALL of the genes, so then we can check what's happening to our favorite genes.

There are a bunch of ways to join datasets together on common keys. We can try out a bunch of these `join` methods and see what we get.

A "key" that both datasets have in common is the "systematic name". However, this list of gene IDs is labeled "SystematicName" in the Dryad annotations, but labeled "ORF" in Dataset01 (mRNA). Let's change the name of one of the columns to match:

```{r}
names(mRNA)[1] <- "SystematicName"

mRNA
```

Let's perform a `left_join()` on the two datasets, following this format:

`joined_df <- left_join(x, y, by = "key")`

This will take all rows of dataframe 'x', & keep all of the columns in 'x', while merging dataframe 'y' on the desired key and appending columns from 'y', with values that correctly correspond to each key.

That might sound confusing at first, so let's just see what happens:

```{r}
mRNA_named <- left_join(mRNA, scer_gene_names, by = "SystematicName")

mRNA_named
```

This will let us search (via their common names) whether our favorite genes are indeed periodically expressed. For example:

```{r}
filter(mRNA_named, Gene %in% c("ACT1", "NOP16", "NOP56"))
```

There are definitely some fluctuations in mRNA. Interesting! Maybe they just didn't make the cut according to the parameters/thresholds used by the authors; or, maybe they just weren't identified in both the 2017 and 1998 papers. Following the authors' methodology, your data is now set up for you to find the culprit (on your own time, if you're interested). 

## Saving your work

You've done all this work - be sure to save it now!

```{r}
write_csv(mRNA_named, "../data/mRNA_data_with_gene_names.csv")
```

## Reshaping tibbles

Sometimes, we might want to reshape a tibble to make it better formatted for plotting/visualization later on. For example, let's go back to Dataset01:

```{r}
mRNA

gather(mRNA_named,key=Vol,value="log2_ratio",-SystematicName,-Gene)
```

What do you notice changed about Dataset01?

This is easier to deal with now, if we want to visualize the data. But let's make our lives even easier with the help of a few additional functions:

```{r}
gather(mRNA_named,key=Vol,value="log2_ratio",-SystematicName,-Gene) %>%
    separate(Vol,into="Vol_fL")
```

```{r}
gather(mRNA_named,key=Vol,value="log2_ratio",-SystematicName,-Gene) %>%
    separate(Vol,into="Vol_fL")  %>%
    mutate(Vol_fL = as.numeric(Vol_fL))
```

Wait, doesn't that look exactly the same? What was the purpose of `mutate()`?

```{r}
mRNA_data_gathered <- 
gather(mRNA_data,key=Vol,value="log2_ratio",-Name,-Gene) %>%
    separate(Vol,into="Vol_fL") %>%
    mutate(Vol_fL = as.numeric(Vol_fL))
```

Now, we can easily pick 3 genes we're most interested in, and plot their fluctuating mRNA levels over the course of the cell cycle!

Let's save that information into a small dataframe, and then Kayla and Gabe will guide you through plotting.

```{r}
mRNA_data_3genes <- filter(mRNA_data_gathered, Gene %in% c("ACT1","NOP16","NOP56"))
```

(If you'd like, you can save this as a .csv as well).

## Questions?
=======
Pivoting data is important 
>>>>>>> Stashed changes
